var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _TagGlue_db, _TagDescriptions_db;
import util from 'node:util';
import SqlString from 'sqlstring-sqlite';
// function to initialize a TAGGLUE database table
export class TagGlue {
    constructor() {
        _TagGlue_db.set(this, void 0);
    }
    get db() { return __classPrivateFieldGet(this, _TagGlue_db, "f"); }
    async init(db) {
        __classPrivateFieldSet(this, _TagGlue_db, db, "f");
        // console.log(`
        // CREATE TABLE IF NOT EXISTS
        // TAGGLUE (
        //     docvpath STRING,
        //     tagName STRING
        // );
        // CREATE INDEX IF NOT EXISTS 
        //     tagglue_vpath on TAGGLUE (docvpath);
        // CREATE INDEX IF NOT EXISTS
        //     tagglue_name  on TAGGLUE (tagName);
        // CREATE UNIQUE INDEX IF NOT EXISTS
        //     tagglue_tuple ON TAGGLUE (docvpath, tagName);
        //     `)
        await this.db.run(`
        CREATE TABLE IF NOT EXISTS
        TAGGLUE (
            docvpath STRING,
            tagName STRING
        );
        CREATE INDEX IF NOT EXISTS 
            tagglue_vpath on TAGGLUE (docvpath);
        CREATE INDEX IF NOT EXISTS
            tagglue_name  on TAGGLUE (tagName);
        CREATE UNIQUE INDEX IF NOT EXISTS
            tagglue_tuple ON TAGGLUE (docvpath, tagName);
        `);
    }
    async addTagGlue(vpath, tags) {
        for (const tag of tags) {
            // console.log(`
            // INSERT INTO TAGGLUE (
            //     docvpath, tagName
            // )
            // VALUES (
            //     ${vpath}, ${tag}
            // )
            // `)
            await this.db.run(`
            INSERT INTO TAGGLUE (
                docvpath, tagName
            )
            VALUES (
                $vpath, $tag
            )
            `, {
                $vpath: vpath,
                $tag: tag
            });
        }
    }
    async deleteTagGlue(vpath) {
        try {
            await this.db.run(`DELETE FROM TAGGLUE WHERE docvpath = $vpath`, {
                $vpath: vpath,
            });
        }
        catch (err) {
        }
    }
    async tags() {
        const rows = await this.db.all(`SELECT DISTINCT tagName AS tag 
            FROM TAGGLUE`);
        return rows.map((item) => {
            return item.tag;
        });
    }
    async pathsForTag(tagName) {
        let rows;
        if (typeof tagName === 'string') {
            rows = await this.db.all(`
                SELECT DISTINCT docvpath AS vpath
                FROM TAGGLUE
                WHERE tagName = $tag
                `, {
                $tag: tagName
            });
        }
        else {
            let tagstring = ` (
                ${SqlString.escape(tagName)}
            )`;
            // console.log(tagstring);
            // console.log(`
            //     SELECT DISTINCT docvpath AS vpath
            //     FROM TAGGLUE
            //     WHERE tagName IN ${tagstring}
            //     `)
            rows = await this.db.all(`
                SELECT DISTINCT docvpath AS vpath
                FROM TAGGLUE
                WHERE tagName IN ${tagstring}
                `);
        }
        // console.log(`pathsForTag ${util.inspect(tagName)}`);
        return rows.map(item => {
            return item.vpath;
        });
    }
}
_TagGlue_db = new WeakMap();
export class TagDescriptions {
    constructor() {
        _TagDescriptions_db.set(this, void 0);
    }
    get db() { return __classPrivateFieldGet(this, _TagDescriptions_db, "f"); }
    async init(db) {
        // console.log(`TagDescriptions 
        // CREATE TABLE IF NOT EXISTS
        // TAGDESCRIPTION (
        //     tagName STRING UNIQUE,
        //     description STRING
        // );
        // CREATE UNIQUE INDEX IF NOT EXISTS
        //     tagdesc_name  on TAGDESCRIPTION (tagName);`)
        __classPrivateFieldSet(this, _TagDescriptions_db, db, "f");
        await this.db.run(`
        CREATE TABLE IF NOT EXISTS
        TAGDESCRIPTION (
            tagName STRING UNIQUE,
            description STRING
        );
        CREATE UNIQUE INDEX IF NOT EXISTS
            tagdesc_name  on TAGDESCRIPTION (tagName);
        `);
    }
    async addDesc(tag, description) {
        // console.log(`TagDescriptions addDesc ${tag} ${description}`);
        await this.db.run(`
        INSERT INTO TAGDESCRIPTION (
            tagName, description
        )
        VALUES (
            $tag, $desc
        )
        `, {
            $tag: tag,
            $desc: description
        });
    }
    async deleteDesc(tag) {
        // console.log(`TagDescriptions deleteDesc ${tag}`);
        try {
            await this.db.run(`DELETE FROM TAGDESCRIPTION
                WHERE tagName = $tag`, {
                $tag: tag
            });
        }
        catch (err) {
        }
    }
    async getDesc(tag) {
        // console.log(`TagDescriptions getDesc ${tag}`);
        const rows = await this.db.all(`SELECT description FROM TAGDESCRIPTION
                WHERE tagName = $tag`, {
            $tag: tag
        });
        if (rows.length <= 0) {
            // throw new Error(`No tag information found for ${util.inspect(tag)}`);
            return undefined;
        }
        if (rows.length > 1) {
            throw new Error(`UNEXPECTED CONDITION more than one tag entry for ${util.inspect(tag)}`);
        }
        return (rows[0].description === null
            || typeof rows[0].description === 'undefined')
            ? undefined
            : rows[0].description;
    }
}
_TagDescriptions_db = new WeakMap();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFnLWdsdWUtbmV3LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vbGliL2NhY2hlL3RhZy1nbHVlLW5ldy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFDQSxPQUFPLElBQUksTUFBTSxXQUFXLENBQUM7QUFJN0IsT0FBTyxTQUFTLE1BQU0sa0JBQWtCLENBQUM7QUFFekMsa0RBQWtEO0FBRWxELE1BQU0sT0FBTyxPQUFPO0lBQXBCO1FBQ0ksOEJBQW1CO0lBMEh2QixDQUFDO0lBeEhHLElBQUksRUFBRSxLQUFvQixPQUFPLHVCQUFBLElBQUksbUJBQUksQ0FBQyxDQUFDLENBQUM7SUFFNUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFpQjtRQUN4Qix1QkFBQSxJQUFJLGVBQU8sRUFBRSxNQUFBLENBQUM7UUFFZCxnQkFBZ0I7UUFDaEIsNkJBQTZCO1FBQzdCLFlBQVk7UUFDWix1QkFBdUI7UUFDdkIscUJBQXFCO1FBQ3JCLEtBQUs7UUFDTCw4QkFBOEI7UUFDOUIsMkNBQTJDO1FBQzNDLDZCQUE2QjtRQUM3QiwwQ0FBMEM7UUFDMUMsb0NBQW9DO1FBQ3BDLG9EQUFvRDtRQUNwRCxTQUFTO1FBQ1QsTUFBTSxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQzs7Ozs7Ozs7Ozs7O1NBWWpCLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFRCxLQUFLLENBQUMsVUFBVSxDQUFDLEtBQWEsRUFBRSxJQUFjO1FBQzFDLEtBQUssTUFBTSxHQUFHLElBQUksSUFBSSxFQUFFLENBQUM7WUFDckIsZ0JBQWdCO1lBQ2hCLHdCQUF3QjtZQUN4Qix3QkFBd0I7WUFDeEIsSUFBSTtZQUNKLFdBQVc7WUFDWCx1QkFBdUI7WUFDdkIsSUFBSTtZQUNKLEtBQUs7WUFDTCxNQUFNLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDOzs7Ozs7O2FBT2pCLEVBQUU7Z0JBQ0MsTUFBTSxFQUFFLEtBQUs7Z0JBQ2IsSUFBSSxFQUFFLEdBQUc7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LE1BQU0sSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQ2xCO3FDQUN5QixFQUFFO1lBQ25CLElBQUksRUFBRSxHQUFHO1NBQ1osQ0FBQyxDQUFDO1FBQ1gsSUFBSSxJQUFJLENBQUMsTUFBTSxJQUFJLENBQUMsRUFBRSxDQUFDO1lBQ25CLHdFQUF3RTtZQUN4RSxPQUFPLFNBQVMsQ0FBQztRQUNyQixDQUFDO1FBQ0QsSUFBSSxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDO1lBQ2xCLE1BQU0sSUFBSSxLQUFLLENBQUMsb0RBQW9ELElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQzdGLENBQUM7UUFDRCxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsS0FBSyxJQUFJO2VBQzdCLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsS0FBSyxXQUFXLENBQ2hEO1lBQ0csQ0FBQyxDQUFDLFNBQVM7WUFDWCxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQztJQUM5QixDQUFDO0NBQ0oiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB1dGlsIGZyb20gJ25vZGU6dXRpbCc7XG5cbmltcG9ydCB7IEFzeW5jRGF0YWJhc2UgfSBmcm9tICdwcm9taXNlZC1zcWxpdGUzJztcblxuaW1wb3J0IFNxbFN0cmluZyBmcm9tICdzcWxzdHJpbmctc3FsaXRlJztcblxuLy8gZnVuY3Rpb24gdG8gaW5pdGlhbGl6ZSBhIFRBR0dMVUUgZGF0YWJhc2UgdGFibGVcblxuZXhwb3J0IGNsYXNzIFRhZ0dsdWUge1xuICAgICNkYjogQXN5bmNEYXRhYmFzZTtcblxuICAgIGdldCBkYigpOiBBc3luY0RhdGFiYXNlIHsgcmV0dXJuIHRoaXMuI2RiOyB9XG5cbiAgICBhc3luYyBpbml0KGRiOiBBc3luY0RhdGFiYXNlKSB7XG4gICAgICAgIHRoaXMuI2RiID0gZGI7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coYFxuICAgICAgICAvLyBDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUU1xuICAgICAgICAvLyBUQUdHTFVFIChcbiAgICAgICAgLy8gICAgIGRvY3ZwYXRoIFNUUklORyxcbiAgICAgICAgLy8gICAgIHRhZ05hbWUgU1RSSU5HXG4gICAgICAgIC8vICk7XG4gICAgICAgIC8vIENSRUFURSBJTkRFWCBJRiBOT1QgRVhJU1RTIFxuICAgICAgICAvLyAgICAgdGFnZ2x1ZV92cGF0aCBvbiBUQUdHTFVFIChkb2N2cGF0aCk7XG4gICAgICAgIC8vIENSRUFURSBJTkRFWCBJRiBOT1QgRVhJU1RTXG4gICAgICAgIC8vICAgICB0YWdnbHVlX25hbWUgIG9uIFRBR0dMVUUgKHRhZ05hbWUpO1xuICAgICAgICAvLyBDUkVBVEUgVU5JUVVFIElOREVYIElGIE5PVCBFWElTVFNcbiAgICAgICAgLy8gICAgIHRhZ2dsdWVfdHVwbGUgT04gVEFHR0xVRSAoZG9jdnBhdGgsIHRhZ05hbWUpO1xuICAgICAgICAvLyAgICAgYClcbiAgICAgICAgYXdhaXQgdGhpcy5kYi5ydW4oYFxuICAgICAgICBDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUU1xuICAgICAgICBUQUdHTFVFIChcbiAgICAgICAgICAgIGRvY3ZwYXRoIFNUUklORyxcbiAgICAgICAgICAgIHRhZ05hbWUgU1RSSU5HXG4gICAgICAgICk7XG4gICAgICAgIENSRUFURSBJTkRFWCBJRiBOT1QgRVhJU1RTIFxuICAgICAgICAgICAgdGFnZ2x1ZV92cGF0aCBvbiBUQUdHTFVFIChkb2N2cGF0aCk7XG4gICAgICAgIENSRUFURSBJTkRFWCBJRiBOT1QgRVhJU1RTXG4gICAgICAgICAgICB0YWdnbHVlX25hbWUgIG9uIFRBR0dMVUUgKHRhZ05hbWUpO1xuICAgICAgICBDUkVBVEUgVU5JUVVFIElOREVYIElGIE5PVCBFWElTVFNcbiAgICAgICAgICAgIHRhZ2dsdWVfdHVwbGUgT04gVEFHR0xVRSAoZG9jdnBhdGgsIHRhZ05hbWUpO1xuICAgICAgICBgKTtcbiAgICB9XG5cbiAgICBhc3luYyBhZGRUYWdHbHVlKHZwYXRoOiBzdHJpbmcsIHRhZ3M6IHN0cmluZ1tdKSB7XG4gICAgICAgIGZvciAoY29uc3QgdGFnIG9mIHRhZ3MpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGBcbiAgICAgICAgICAgIC8vIElOU0VSVCBJTlRPIFRBR0dMVUUgKFxuICAgICAgICAgICAgLy8gICAgIGRvY3ZwYXRoLCB0YWdOYW1lXG4gICAgICAgICAgICAvLyApXG4gICAgICAgICAgICAvLyBWQUxVRVMgKFxuICAgICAgICAgICAgLy8gICAgICR7dnBhdGh9LCAke3RhZ31cbiAgICAgICAgICAgIC8vIClcbiAgICAgICAgICAgIC8vIGApXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRiLnJ1bihgXG4gICAgICAgICAgICBJTlNFUlQgSU5UTyBUQUdHTFVFIChcbiAgICAgICAgICAgICAgICBkb2N2cGF0aCwgdGFnTmFtZVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgVkFMVUVTIChcbiAgICAgICAgICAgICAgICAkdnBhdGgsICR0YWdcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIGAsIHtcbiAgICAgICAgICAgICAgICAkdnBhdGg6IHZwYXRoLFxuICAgICAgICAgICAgICAgICR0YWc6IHRhZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBkZWxldGVUYWdHbHVlKHZwYXRoOiBzdHJpbmcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZGIucnVuKFxuICAgICAgICAgICAgICAgIGBERUxFVEUgRlJPTSBUQUdHTFVFIFdIRVJFIGRvY3ZwYXRoID0gJHZwYXRoYCwge1xuICAgICAgICAgICAgICAgICAgICAkdnBhdGg6IHZwYXRoLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgdGFncygpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgICAgIGNvbnN0IHJvd3MgPSA8e1xuICAgICAgICAgICAgdGFnOiBzdHJpbmdcbiAgICAgICAgfVtdPiBhd2FpdCB0aGlzLmRiLmFsbChcbiAgICAgICAgICAgIGBTRUxFQ1QgRElTVElOQ1QgdGFnTmFtZSBBUyB0YWcgXG4gICAgICAgICAgICBGUk9NIFRBR0dMVUVgKTtcbiAgICAgICAgcmV0dXJuIHJvd3MubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS50YWc7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIHBhdGhzRm9yVGFnKHRhZ05hbWU6IHN0cmluZyB8IHN0cmluZ1tdKVxuICAgICAgICA6IFByb21pc2U8c3RyaW5nW10+XG4gICAge1xuICAgICAgICBsZXQgcm93cztcbiAgICAgICAgaWYgKHR5cGVvZiB0YWdOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcm93cyA9IDx7XG4gICAgICAgICAgICAgICAgdnBhdGg6IHN0cmluZ1xuICAgICAgICAgICAgfVtdPiBhd2FpdCB0aGlzLmRiLmFsbChgXG4gICAgICAgICAgICAgICAgU0VMRUNUIERJU1RJTkNUIGRvY3ZwYXRoIEFTIHZwYXRoXG4gICAgICAgICAgICAgICAgRlJPTSBUQUdHTFVFXG4gICAgICAgICAgICAgICAgV0hFUkUgdGFnTmFtZSA9ICR0YWdcbiAgICAgICAgICAgICAgICBgLCB7XG4gICAgICAgICAgICAgICAgICAgICR0YWc6IHRhZ05hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgbGV0IHRhZ3N0cmluZyA9IGAgKFxuICAgICAgICAgICAgICAgICR7U3FsU3RyaW5nLmVzY2FwZSh0YWdOYW1lKX1cbiAgICAgICAgICAgIClgO1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0YWdzdHJpbmcpO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYFxuICAgICAgICAgICAgLy8gICAgIFNFTEVDVCBESVNUSU5DVCBkb2N2cGF0aCBBUyB2cGF0aFxuICAgICAgICAgICAgLy8gICAgIEZST00gVEFHR0xVRVxuICAgICAgICAgICAgLy8gICAgIFdIRVJFIHRhZ05hbWUgSU4gJHt0YWdzdHJpbmd9XG4gICAgICAgICAgICAvLyAgICAgYClcblxuICAgICAgICAgICAgcm93cyA9IDx7XG4gICAgICAgICAgICAgICAgdnBhdGg6IHN0cmluZ1xuICAgICAgICAgICAgfVtdPiBhd2FpdCB0aGlzLmRiLmFsbChgXG4gICAgICAgICAgICAgICAgU0VMRUNUIERJU1RJTkNUIGRvY3ZwYXRoIEFTIHZwYXRoXG4gICAgICAgICAgICAgICAgRlJPTSBUQUdHTFVFXG4gICAgICAgICAgICAgICAgV0hFUkUgdGFnTmFtZSBJTiAke3RhZ3N0cmluZ31cbiAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhgcGF0aHNGb3JUYWcgJHt1dGlsLmluc3BlY3QodGFnTmFtZSl9YCk7XG4gICAgICAgIHJldHVybiByb3dzLm1hcChpdGVtID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLnZwYXRoO1xuICAgICAgICB9KTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IGNsYXNzIFRhZ0Rlc2NyaXB0aW9ucyB7XG5cbiAgICAjZGI6IEFzeW5jRGF0YWJhc2U7XG5cbiAgICBnZXQgZGIoKTogQXN5bmNEYXRhYmFzZSB7IHJldHVybiB0aGlzLiNkYjsgfVxuXG4gICAgYXN5bmMgaW5pdChkYjogQXN5bmNEYXRhYmFzZSkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhgVGFnRGVzY3JpcHRpb25zIFxuICAgICAgICAvLyBDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUU1xuICAgICAgICAvLyBUQUdERVNDUklQVElPTiAoXG4gICAgICAgIC8vICAgICB0YWdOYW1lIFNUUklORyBVTklRVUUsXG4gICAgICAgIC8vICAgICBkZXNjcmlwdGlvbiBTVFJJTkdcbiAgICAgICAgLy8gKTtcbiAgICAgICAgLy8gQ1JFQVRFIFVOSVFVRSBJTkRFWCBJRiBOT1QgRVhJU1RTXG4gICAgICAgIC8vICAgICB0YWdkZXNjX25hbWUgIG9uIFRBR0RFU0NSSVBUSU9OICh0YWdOYW1lKTtgKVxuICAgICAgICB0aGlzLiNkYiA9IGRiO1xuXG4gICAgICAgIGF3YWl0IHRoaXMuZGIucnVuKGBcbiAgICAgICAgQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFNcbiAgICAgICAgVEFHREVTQ1JJUFRJT04gKFxuICAgICAgICAgICAgdGFnTmFtZSBTVFJJTkcgVU5JUVVFLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24gU1RSSU5HXG4gICAgICAgICk7XG4gICAgICAgIENSRUFURSBVTklRVUUgSU5ERVggSUYgTk9UIEVYSVNUU1xuICAgICAgICAgICAgdGFnZGVzY19uYW1lICBvbiBUQUdERVNDUklQVElPTiAodGFnTmFtZSk7XG4gICAgICAgIGApO1xuICAgIH1cblxuICAgIGFzeW5jIGFkZERlc2ModGFnOiBzdHJpbmcsIGRlc2NyaXB0aW9uOiBzdHJpbmcpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coYFRhZ0Rlc2NyaXB0aW9ucyBhZGREZXNjICR7dGFnfSAke2Rlc2NyaXB0aW9ufWApO1xuICAgICAgICBhd2FpdCB0aGlzLmRiLnJ1bihgXG4gICAgICAgIElOU0VSVCBJTlRPIFRBR0RFU0NSSVBUSU9OIChcbiAgICAgICAgICAgIHRhZ05hbWUsIGRlc2NyaXB0aW9uXG4gICAgICAgIClcbiAgICAgICAgVkFMVUVTIChcbiAgICAgICAgICAgICR0YWcsICRkZXNjXG4gICAgICAgIClcbiAgICAgICAgYCwge1xuICAgICAgICAgICAgJHRhZzogdGFnLFxuICAgICAgICAgICAgJGRlc2M6IGRlc2NyaXB0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGRlbGV0ZURlc2ModGFnOiBzdHJpbmcpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coYFRhZ0Rlc2NyaXB0aW9ucyBkZWxldGVEZXNjICR7dGFnfWApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5kYi5ydW4oXG4gICAgICAgICAgICAgICAgYERFTEVURSBGUk9NIFRBR0RFU0NSSVBUSU9OXG4gICAgICAgICAgICAgICAgV0hFUkUgdGFnTmFtZSA9ICR0YWdgLCB7XG4gICAgICAgICAgICAgICAgICAgICR0YWc6IHRhZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0RGVzYyhcbiAgICAgICAgdGFnOiBzdHJpbmdcbiAgICApOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGBUYWdEZXNjcmlwdGlvbnMgZ2V0RGVzYyAke3RhZ31gKTtcbiAgICAgICAgY29uc3Qgcm93cyA9IDx7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogc3RyaW5nXG4gICAgICAgIH1bXT4gYXdhaXQgdGhpcy5kYi5hbGwoXG4gICAgICAgICAgICBgU0VMRUNUIGRlc2NyaXB0aW9uIEZST00gVEFHREVTQ1JJUFRJT05cbiAgICAgICAgICAgICAgICBXSEVSRSB0YWdOYW1lID0gJHRhZ2AsIHtcbiAgICAgICAgICAgICAgICAgICAgJHRhZzogdGFnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmIChyb3dzLmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoYE5vIHRhZyBpbmZvcm1hdGlvbiBmb3VuZCBmb3IgJHt1dGlsLmluc3BlY3QodGFnKX1gKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvd3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVTkVYUEVDVEVEIENPTkRJVElPTiBtb3JlIHRoYW4gb25lIHRhZyBlbnRyeSBmb3IgJHt1dGlsLmluc3BlY3QodGFnKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHJvd3NbMF0uZGVzY3JpcHRpb24gPT09IG51bGxcbiAgICAgICAgICAgIHx8IHR5cGVvZiByb3dzWzBdLmRlc2NyaXB0aW9uID09PSAndW5kZWZpbmVkJ1xuICAgICAgICApXG4gICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiByb3dzWzBdLmRlc2NyaXB0aW9uO1xuICAgIH1cbn1cbiJdfQ==