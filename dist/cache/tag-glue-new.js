var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _TagGlue_db, _TagDescriptions_db;
import util from 'node:util';
// Use this.dao.sqldb to get Database instance
// function to initialize a TAGGLUE database table
export class TagGlue {
    constructor() {
        _TagGlue_db.set(this, void 0);
    }
    get db() { return __classPrivateFieldGet(this, _TagGlue_db, "f"); }
    async init(db) {
        __classPrivateFieldSet(this, _TagGlue_db, db, "f");
        // console.log(`
        // CREATE TABLE IF NOT EXISTS
        // TAGGLUE (
        //     docvpath STRING,
        //     tagName STRING
        // );
        // CREATE INDEX IF NOT EXISTS 
        //     tagglue_vpath on TAGGLUE (docvpath);
        // CREATE INDEX IF NOT EXISTS
        //     tagglue_name  on TAGGLUE (tagName);
        // CREATE UNIQUE INDEX IF NOT EXISTS
        //     tagglue_tuple ON TAGGLUE (docvpath, tagName);
        //     `)
        await this.db.run(`
        CREATE TABLE IF NOT EXISTS
        TAGGLUE (
            docvpath STRING,
            tagName STRING
        );
        CREATE INDEX IF NOT EXISTS 
            tagglue_vpath on TAGGLUE (docvpath);
        CREATE INDEX IF NOT EXISTS
            tagglue_name  on TAGGLUE (tagName);
        CREATE UNIQUE INDEX IF NOT EXISTS
            tagglue_tuple ON TAGGLUE (docvpath, tagName);
        `);
    }
    async addTagGlue(vpath, tags) {
        for (const tag of tags) {
            // console.log(`
            // INSERT INTO TAGGLUE (
            //     docvpath, tagName
            // )
            // VALUES (
            //     ${vpath}, ${tag}
            // )
            // `)
            await this.db.run(`
            INSERT INTO TAGGLUE (
                docvpath, tagName
            )
            VALUES (
                $vpath, $tag
            )
            `, {
                $vpath: vpath,
                $tag: tag
            });
        }
    }
    async deleteTagGlue(vpath) {
        try {
            await this.db.run(`DELETE FROM TAGGLUE WHERE docvpath = $vpath`, {
                $vpath: vpath,
            });
        }
        catch (err) {
        }
    }
    async tags() {
        const rows = await this.db.all(`SELECT DISTINCT tagName AS tag 
            FROM TAGGLUE`);
        return rows.map((item) => {
            return item.tag;
        });
    }
    async pathsForTag(tagName) {
        let rows;
        if (typeof tagName === 'string') {
            rows = await this.db.all(`
                SELECT DISTINCT docvpath AS vpath
                FROM TAGGLUE
                WHERE tagName = $tag
                `, {
                $tag: tagName
            });
        }
        else {
            let tagstring = ` ( ${tagName.map(t => {
                return `'${t.indexOf("'") >= 0
                    ? t.replaceAll("'", "''")
                    : t}'`;
            }).join(',')} ) `;
            // console.log(tagstring);
            rows = await this.db.all(`
                SELECT DISTINCT docvpath AS vpath
                FROM TAGGLUE
                WHERE tagName IN ${tagstring}
                `);
        }
        // console.log(`pathsForTag ${util.inspect(tagName)}`);
        return rows.map(item => {
            return item.vpath;
        });
    }
}
_TagGlue_db = new WeakMap();
export class TagDescriptions {
    constructor() {
        _TagDescriptions_db.set(this, void 0);
    }
    get db() { return __classPrivateFieldGet(this, _TagDescriptions_db, "f"); }
    async init(db) {
        // console.log(`TagDescriptions 
        // CREATE TABLE IF NOT EXISTS
        // TAGDESCRIPTION (
        //     tagName STRING UNIQUE,
        //     description STRING
        // );
        // CREATE UNIQUE INDEX IF NOT EXISTS
        //     tagdesc_name  on TAGDESCRIPTION (tagName);`)
        __classPrivateFieldSet(this, _TagDescriptions_db, db, "f");
        await this.db.run(`
        CREATE TABLE IF NOT EXISTS
        TAGDESCRIPTION (
            tagName STRING UNIQUE,
            description STRING
        );
        CREATE UNIQUE INDEX IF NOT EXISTS
            tagdesc_name  on TAGDESCRIPTION (tagName);
        `);
    }
    async addDesc(tag, description) {
        // console.log(`TagDescriptions addDesc ${tag} ${description}`);
        await this.db.run(`
        INSERT INTO TAGDESCRIPTION (
            tagName, description
        )
        VALUES (
            $tag, $desc
        )
        `, {
            $tag: tag,
            $desc: description
        });
    }
    async deleteDesc(tag) {
        // console.log(`TagDescriptions deleteDesc ${tag}`);
        try {
            await this.db.run(`DELETE FROM TAGDESCRIPTION
                WHERE tagName = $tag`, {
                $tag: tag
            });
        }
        catch (err) {
        }
    }
    async getDesc(tag) {
        // console.log(`TagDescriptions getDesc ${tag}`);
        const rows = await this.db.all(`SELECT description FROM TAGDESCRIPTION
                WHERE tagName = $tag`, {
            $tag: tag
        });
        if (rows.length <= 0) {
            // throw new Error(`No tag information found for ${util.inspect(tag)}`);
            return undefined;
        }
        if (rows.length > 1) {
            throw new Error(`UNEXPECTED CONDITION more than one tag entry for ${util.inspect(tag)}`);
        }
        return (rows[0].description === null
            || typeof rows[0].description === 'undefined')
            ? undefined
            : rows[0].description;
    }
}
_TagDescriptions_db = new WeakMap();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFnLWdsdWUtbmV3LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vbGliL2NhY2hlL3RhZy1nbHVlLW5ldy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFDQSxPQUFPLElBQUksTUFBTSxXQUFXLENBQUM7QUFLN0IsOENBQThDO0FBRTlDLGtEQUFrRDtBQUVsRCxNQUFNLE9BQU8sT0FBTztJQUFwQjtRQUNJLDhCQUFtQjtJQXVIdkIsQ0FBQztJQXJIRyxJQUFJLEVBQUUsS0FBb0IsT0FBTyx1QkFBQSxJQUFJLG1CQUFJLENBQUMsQ0FBQyxDQUFDO0lBRTVDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBaUI7UUFDeEIsdUJBQUEsSUFBSSxlQUFPLEVBQUUsTUFBQSxDQUFDO1FBRWQsZ0JBQWdCO1FBQ2hCLDZCQUE2QjtRQUM3QixZQUFZO1FBQ1osdUJBQXVCO1FBQ3ZCLHFCQUFxQjtRQUNyQixLQUFLO1FBQ0wsOEJBQThCO1FBQzlCLDJDQUEyQztRQUMzQyw2QkFBNkI7UUFDN0IsMENBQTBDO1FBQzFDLG9DQUFvQztRQUNwQyxvREFBb0Q7UUFDcEQsU0FBUztRQUNULE1BQU0sSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUM7Ozs7Ozs7Ozs7OztTQVlqQixDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQsS0FBSyxDQUFDLFVBQVUsQ0FBQyxLQUFhLEVBQUUsSUFBYztRQUMxQyxLQUFLLE1BQU0sR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDO1lBQ3JCLGdCQUFnQjtZQUNoQix3QkFBd0I7WUFDeEIsd0JBQXdCO1lBQ3hCLElBQUk7WUFDSixXQUFXO1lBQ1gsdUJBQXVCO1lBQ3ZCLElBQUk7WUFDSixLQUFLO1lBQ0wsTUFBTSxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQzs7Ozs7OzthQU9qQixFQUFFO2dCQUNDLE1BQU0sRUFBRSxLQUFLO2dCQUNiLElBQUksRUFBRSxHQUFHO2FBQ1osQ0FBQyxDQUFDO1FBQ1As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O1FBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQztRQUNmLENBQUM7SUFDTCxDQUFDO0lBRUQsS0FBSyxDQUFDLE9BQU8sQ0FDVCxHQUFXO1FBR1gsaURBQWlEO1FBQ2pELE1BQU0sSUFBSSxHQUVMLE1BQU0sSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQ2xCO3FDQUN5QixFQUFFO1lBQ25CLElBQUksRUFBRSxHQUFHO1NBQ1osQ0FBQyxDQUFDO1FBQ1gsSUFBSSxJQUFJLENBQUMsTUFBTSxJQUFJLENBQUMsRUFBRSxDQUFDO1lBQ25CLHdFQUF3RTtZQUN4RSxPQUFPLFNBQVMsQ0FBQztRQUNyQixDQUFDO1FBQ0QsSUFBSSxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDO1lBQ2xCLE1BQU0sSUFBSSxLQUFLLENBQUMsb0RBQW9ELElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQzdGLENBQUM7UUFDRCxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsS0FBSyxJQUFJO2VBQzdCLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsS0FBSyxXQUFXLENBQ2hEO1lBQ0csQ0FBQyxDQUFDLFNBQVM7WUFDWCxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQztJQUM5QixDQUFDO0NBQ0oiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB1dGlsIGZyb20gJ25vZGU6dXRpbCc7XG4vLyBpbXBvcnQgeyBEYXRhYmFzZSB9IGZyb20gJ3NxbGl0ZTMnO1xuXG5pbXBvcnQgeyBBc3luY0RhdGFiYXNlIH0gZnJvbSAncHJvbWlzZWQtc3FsaXRlMyc7XG5cbi8vIFVzZSB0aGlzLmRhby5zcWxkYiB0byBnZXQgRGF0YWJhc2UgaW5zdGFuY2VcblxuLy8gZnVuY3Rpb24gdG8gaW5pdGlhbGl6ZSBhIFRBR0dMVUUgZGF0YWJhc2UgdGFibGVcblxuZXhwb3J0IGNsYXNzIFRhZ0dsdWUge1xuICAgICNkYjogQXN5bmNEYXRhYmFzZTtcblxuICAgIGdldCBkYigpOiBBc3luY0RhdGFiYXNlIHsgcmV0dXJuIHRoaXMuI2RiOyB9XG5cbiAgICBhc3luYyBpbml0KGRiOiBBc3luY0RhdGFiYXNlKSB7XG4gICAgICAgIHRoaXMuI2RiID0gZGI7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coYFxuICAgICAgICAvLyBDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUU1xuICAgICAgICAvLyBUQUdHTFVFIChcbiAgICAgICAgLy8gICAgIGRvY3ZwYXRoIFNUUklORyxcbiAgICAgICAgLy8gICAgIHRhZ05hbWUgU1RSSU5HXG4gICAgICAgIC8vICk7XG4gICAgICAgIC8vIENSRUFURSBJTkRFWCBJRiBOT1QgRVhJU1RTIFxuICAgICAgICAvLyAgICAgdGFnZ2x1ZV92cGF0aCBvbiBUQUdHTFVFIChkb2N2cGF0aCk7XG4gICAgICAgIC8vIENSRUFURSBJTkRFWCBJRiBOT1QgRVhJU1RTXG4gICAgICAgIC8vICAgICB0YWdnbHVlX25hbWUgIG9uIFRBR0dMVUUgKHRhZ05hbWUpO1xuICAgICAgICAvLyBDUkVBVEUgVU5JUVVFIElOREVYIElGIE5PVCBFWElTVFNcbiAgICAgICAgLy8gICAgIHRhZ2dsdWVfdHVwbGUgT04gVEFHR0xVRSAoZG9jdnBhdGgsIHRhZ05hbWUpO1xuICAgICAgICAvLyAgICAgYClcbiAgICAgICAgYXdhaXQgdGhpcy5kYi5ydW4oYFxuICAgICAgICBDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUU1xuICAgICAgICBUQUdHTFVFIChcbiAgICAgICAgICAgIGRvY3ZwYXRoIFNUUklORyxcbiAgICAgICAgICAgIHRhZ05hbWUgU1RSSU5HXG4gICAgICAgICk7XG4gICAgICAgIENSRUFURSBJTkRFWCBJRiBOT1QgRVhJU1RTIFxuICAgICAgICAgICAgdGFnZ2x1ZV92cGF0aCBvbiBUQUdHTFVFIChkb2N2cGF0aCk7XG4gICAgICAgIENSRUFURSBJTkRFWCBJRiBOT1QgRVhJU1RTXG4gICAgICAgICAgICB0YWdnbHVlX25hbWUgIG9uIFRBR0dMVUUgKHRhZ05hbWUpO1xuICAgICAgICBDUkVBVEUgVU5JUVVFIElOREVYIElGIE5PVCBFWElTVFNcbiAgICAgICAgICAgIHRhZ2dsdWVfdHVwbGUgT04gVEFHR0xVRSAoZG9jdnBhdGgsIHRhZ05hbWUpO1xuICAgICAgICBgKTtcbiAgICB9XG5cbiAgICBhc3luYyBhZGRUYWdHbHVlKHZwYXRoOiBzdHJpbmcsIHRhZ3M6IHN0cmluZ1tdKSB7XG4gICAgICAgIGZvciAoY29uc3QgdGFnIG9mIHRhZ3MpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGBcbiAgICAgICAgICAgIC8vIElOU0VSVCBJTlRPIFRBR0dMVUUgKFxuICAgICAgICAgICAgLy8gICAgIGRvY3ZwYXRoLCB0YWdOYW1lXG4gICAgICAgICAgICAvLyApXG4gICAgICAgICAgICAvLyBWQUxVRVMgKFxuICAgICAgICAgICAgLy8gICAgICR7dnBhdGh9LCAke3RhZ31cbiAgICAgICAgICAgIC8vIClcbiAgICAgICAgICAgIC8vIGApXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRiLnJ1bihgXG4gICAgICAgICAgICBJTlNFUlQgSU5UTyBUQUdHTFVFIChcbiAgICAgICAgICAgICAgICBkb2N2cGF0aCwgdGFnTmFtZVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgVkFMVUVTIChcbiAgICAgICAgICAgICAgICAkdnBhdGgsICR0YWdcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIGAsIHtcbiAgICAgICAgICAgICAgICAkdnBhdGg6IHZwYXRoLFxuICAgICAgICAgICAgICAgICR0YWc6IHRhZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBkZWxldGVUYWdHbHVlKHZwYXRoOiBzdHJpbmcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZGIucnVuKFxuICAgICAgICAgICAgICAgIGBERUxFVEUgRlJPTSBUQUdHTFVFIFdIRVJFIGRvY3ZwYXRoID0gJHZwYXRoYCwge1xuICAgICAgICAgICAgICAgICAgICAkdnBhdGg6IHZwYXRoLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgdGFncygpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgICAgIGNvbnN0IHJvd3MgPSA8e1xuICAgICAgICAgICAgdGFnOiBzdHJpbmdcbiAgICAgICAgfVtdPiBhd2FpdCB0aGlzLmRiLmFsbChcbiAgICAgICAgICAgIGBTRUxFQ1QgRElTVElOQ1QgdGFnTmFtZSBBUyB0YWcgXG4gICAgICAgICAgICBGUk9NIFRBR0dMVUVgKTtcbiAgICAgICAgcmV0dXJuIHJvd3MubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS50YWc7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIHBhdGhzRm9yVGFnKHRhZ05hbWU6IHN0cmluZyB8IHN0cmluZ1tdKVxuICAgICAgICA6IFByb21pc2U8c3RyaW5nW10+XG4gICAge1xuICAgICAgICBsZXQgcm93cztcbiAgICAgICAgaWYgKHR5cGVvZiB0YWdOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcm93cyA9IDx7XG4gICAgICAgICAgICAgICAgdnBhdGg6IHN0cmluZ1xuICAgICAgICAgICAgfVtdPiBhd2FpdCB0aGlzLmRiLmFsbChgXG4gICAgICAgICAgICAgICAgU0VMRUNUIERJU1RJTkNUIGRvY3ZwYXRoIEFTIHZwYXRoXG4gICAgICAgICAgICAgICAgRlJPTSBUQUdHTFVFXG4gICAgICAgICAgICAgICAgV0hFUkUgdGFnTmFtZSA9ICR0YWdcbiAgICAgICAgICAgICAgICBgLCB7XG4gICAgICAgICAgICAgICAgICAgICR0YWc6IHRhZ05hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgbGV0IHRhZ3N0cmluZyA9IGAgKCAke3RhZ05hbWUubWFwKHQgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJyR7dC5pbmRleE9mKFwiJ1wiKSA+PSAwXG4gICAgICAgICAgICAgICAgICAgID8gdC5yZXBsYWNlQWxsKFwiJ1wiLCBcIicnXCIpXG4gICAgICAgICAgICAgICAgICAgIDogdH0nYDtcbiAgICAgICAgICAgIH0pLmpvaW4oJywnKX0gKSBgO1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0YWdzdHJpbmcpO1xuXG4gICAgICAgICAgICByb3dzID0gPHtcbiAgICAgICAgICAgICAgICB2cGF0aDogc3RyaW5nXG4gICAgICAgICAgICB9W10+IGF3YWl0IHRoaXMuZGIuYWxsKGBcbiAgICAgICAgICAgICAgICBTRUxFQ1QgRElTVElOQ1QgZG9jdnBhdGggQVMgdnBhdGhcbiAgICAgICAgICAgICAgICBGUk9NIFRBR0dMVUVcbiAgICAgICAgICAgICAgICBXSEVSRSB0YWdOYW1lIElOICR7dGFnc3RyaW5nfVxuICAgICAgICAgICAgICAgIGApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGBwYXRoc0ZvclRhZyAke3V0aWwuaW5zcGVjdCh0YWdOYW1lKX1gKTtcbiAgICAgICAgcmV0dXJuIHJvd3MubWFwKGl0ZW0gPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0udnBhdGg7XG4gICAgICAgIH0pO1xuICAgIH1cblxufVxuXG5leHBvcnQgY2xhc3MgVGFnRGVzY3JpcHRpb25zIHtcblxuICAgICNkYjogQXN5bmNEYXRhYmFzZTtcblxuICAgIGdldCBkYigpOiBBc3luY0RhdGFiYXNlIHsgcmV0dXJuIHRoaXMuI2RiOyB9XG5cbiAgICBhc3luYyBpbml0KGRiOiBBc3luY0RhdGFiYXNlKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGBUYWdEZXNjcmlwdGlvbnMgXG4gICAgICAgIC8vIENSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTXG4gICAgICAgIC8vIFRBR0RFU0NSSVBUSU9OIChcbiAgICAgICAgLy8gICAgIHRhZ05hbWUgU1RSSU5HIFVOSVFVRSxcbiAgICAgICAgLy8gICAgIGRlc2NyaXB0aW9uIFNUUklOR1xuICAgICAgICAvLyApO1xuICAgICAgICAvLyBDUkVBVEUgVU5JUVVFIElOREVYIElGIE5PVCBFWElTVFNcbiAgICAgICAgLy8gICAgIHRhZ2Rlc2NfbmFtZSAgb24gVEFHREVTQ1JJUFRJT04gKHRhZ05hbWUpO2ApXG4gICAgICAgIHRoaXMuI2RiID0gZGI7XG5cbiAgICAgICAgYXdhaXQgdGhpcy5kYi5ydW4oYFxuICAgICAgICBDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUU1xuICAgICAgICBUQUdERVNDUklQVElPTiAoXG4gICAgICAgICAgICB0YWdOYW1lIFNUUklORyBVTklRVUUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbiBTVFJJTkdcbiAgICAgICAgKTtcbiAgICAgICAgQ1JFQVRFIFVOSVFVRSBJTkRFWCBJRiBOT1QgRVhJU1RTXG4gICAgICAgICAgICB0YWdkZXNjX25hbWUgIG9uIFRBR0RFU0NSSVBUSU9OICh0YWdOYW1lKTtcbiAgICAgICAgYCk7XG4gICAgfVxuXG4gICAgYXN5bmMgYWRkRGVzYyh0YWc6IHN0cmluZywgZGVzY3JpcHRpb246IHN0cmluZykge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhgVGFnRGVzY3JpcHRpb25zIGFkZERlc2MgJHt0YWd9ICR7ZGVzY3JpcHRpb259YCk7XG4gICAgICAgIGF3YWl0IHRoaXMuZGIucnVuKGBcbiAgICAgICAgSU5TRVJUIElOVE8gVEFHREVTQ1JJUFRJT04gKFxuICAgICAgICAgICAgdGFnTmFtZSwgZGVzY3JpcHRpb25cbiAgICAgICAgKVxuICAgICAgICBWQUxVRVMgKFxuICAgICAgICAgICAgJHRhZywgJGRlc2NcbiAgICAgICAgKVxuICAgICAgICBgLCB7XG4gICAgICAgICAgICAkdGFnOiB0YWcsXG4gICAgICAgICAgICAkZGVzYzogZGVzY3JpcHRpb25cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZGVsZXRlRGVzYyh0YWc6IHN0cmluZykge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhgVGFnRGVzY3JpcHRpb25zIGRlbGV0ZURlc2MgJHt0YWd9YCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRiLnJ1bihcbiAgICAgICAgICAgICAgICBgREVMRVRFIEZST00gVEFHREVTQ1JJUFRJT05cbiAgICAgICAgICAgICAgICBXSEVSRSB0YWdOYW1lID0gJHRhZ2AsIHtcbiAgICAgICAgICAgICAgICAgICAgJHRhZzogdGFnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBnZXREZXNjKFxuICAgICAgICB0YWc6IHN0cmluZ1xuICAgICk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coYFRhZ0Rlc2NyaXB0aW9ucyBnZXREZXNjICR7dGFnfWApO1xuICAgICAgICBjb25zdCByb3dzID0gPHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBzdHJpbmdcbiAgICAgICAgfVtdPiBhd2FpdCB0aGlzLmRiLmFsbChcbiAgICAgICAgICAgIGBTRUxFQ1QgZGVzY3JpcHRpb24gRlJPTSBUQUdERVNDUklQVElPTlxuICAgICAgICAgICAgICAgIFdIRVJFIHRhZ05hbWUgPSAkdGFnYCwge1xuICAgICAgICAgICAgICAgICAgICAkdGFnOiB0YWdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJvd3MubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgIC8vIHRocm93IG5ldyBFcnJvcihgTm8gdGFnIGluZm9ybWF0aW9uIGZvdW5kIGZvciAke3V0aWwuaW5zcGVjdCh0YWcpfWApO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm93cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVORVhQRUNURUQgQ09ORElUSU9OIG1vcmUgdGhhbiBvbmUgdGFnIGVudHJ5IGZvciAke3V0aWwuaW5zcGVjdCh0YWcpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAocm93c1swXS5kZXNjcmlwdGlvbiA9PT0gbnVsbFxuICAgICAgICAgICAgfHwgdHlwZW9mIHJvd3NbMF0uZGVzY3JpcHRpb24gPT09ICd1bmRlZmluZWQnXG4gICAgICAgIClcbiAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IHJvd3NbMF0uZGVzY3JpcHRpb247XG4gICAgfVxufVxuIl19