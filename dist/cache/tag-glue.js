var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _TagGlue_db, _TagDescriptions_db;
import util from 'node:util';
// Use this.dao.sqldb to get Database instance
// function to initialize a TAGGLUE database table
export class TagGlue {
    constructor() {
        _TagGlue_db.set(this, void 0);
    }
    get db() { return __classPrivateFieldGet(this, _TagGlue_db, "f"); }
    async init(db) {
        __classPrivateFieldSet(this, _TagGlue_db, db, "f");
        await this.db.run(`
        CREATE TABLE IF NOT EXISTS
        TAGGLUE (
            docvpath STRING,
            tagName STRING
        );
        CREATE INDEX IF NOT EXISTS 
            tagglue_vpath on TAGGLUE (docvpath);
        CREATE INDEX IF NOT EXISTS
            tagglue_name  on TAGGLUE (tagName);
        CREATE UNIQUE INDEX IF NOT EXISTS
            tagglue_tuple ON TAGGLUE (docvpath, tagName)
        `);
    }
    async addTagGlue(vpath, tags) {
        for (const tag of tags) {
            await this.db.run(`
            INSERT INTO TAGGLUE (
                docvpath, tagName
            )
            VALUES (
                $vpath, $tag
            )
            `, {
                $vpath: vpath,
                $tag: tag
            });
        }
    }
    async deleteTagGlue(vpath) {
        try {
            await this.db.run(`DELETE FROM TAGGLUE WHERE docvpath = $vpath`, {
                $vpath: vpath,
            });
        }
        catch (err) {
        }
    }
    async tags() {
        const rows = [];
        await new Promise((resolve, reject) => {
            this.db.each(`SELECT DISTINCT tagName AS tag FROM TAGGLUE`, (err, row) => {
                if (err)
                    reject(err);
                rows.push(row);
            }, (err, count) => {
                if (err)
                    reject(err);
                resolve(count);
            });
        });
        return rows.map((item) => {
            return item.tag;
        });
    }
    async pathsForTag(tagName) {
        const rows = [];
        // console.log(`pathsForTag ${util.inspect(tagName)}`);
        await new Promise((resolve, reject) => {
            if (typeof tagName === 'string') {
                this.db.each(`
                    SELECT DISTINCT docvpath AS vpath
                    FROM TAGGLUE
                    WHERE tagName = $tag
                    `, {
                    $tag: tagName
                }, (err, row) => {
                    if (err)
                        reject(err);
                    rows.push(row);
                }, (err, count) => {
                    if (err)
                        reject(err);
                    resolve(count);
                });
            }
            else if (Array.isArray(tagName)) {
                // Convert the array into the SQL
                // representation of the array
                // suitable for the WHERE clause below.
                let tagstring = ` ( ${tagName.map(t => {
                    return `'${t.indexOf("'") >= 0
                        ? t.replaceAll("'", "''")
                        : t}'`;
                }).join(',')} ) `;
                // console.log(tagstring);
                this.db.each(`
                    SELECT DISTINCT docvpath AS vpath
                    FROM TAGGLUE
                    WHERE tagName IN ${tagstring}
                    `
                // Inserting the tagstring in the
                // normal way did not work, and
                // instead gave a syntax error.
                // Using JavaScript template strings
                // worked, instead.
                //
                // , {
                //     $tags: tagstring
                // }
                , (err, row) => {
                    if (err)
                        reject(err);
                    rows.push(row);
                }, (err, count) => {
                    if (err)
                        reject(err);
                    resolve(count);
                });
            }
        });
        return rows.map(item => {
            return item.vpath;
        });
    }
}
_TagGlue_db = new WeakMap();
export class TagDescriptions {
    constructor() {
        _TagDescriptions_db.set(this, void 0);
    }
    get db() { return __classPrivateFieldGet(this, _TagDescriptions_db, "f"); }
    async init(db) {
        __classPrivateFieldSet(this, _TagDescriptions_db, db, "f");
        await this.db.run(`
        CREATE TABLE IF NOT EXISTS
        TAGDESCRIPTION (
            tagName STRING UNIQUE,
            description STRING
        );
        CREATE UNIQUE INDEX IF NOT EXISTS
            tagdesc_name  on TAGDESCRIPTION (tagName);
        `);
    }
    async addDesc(tag, description) {
        await this.db.run(`
        INSERT INTO TAGDESCRIPTION (
            tagName, description
        )
        VALUES (
            $tag, $desc
        )
        `, {
            $tag: tag,
            $desc: description
        });
    }
    async deleteDesc(tag) {
        try {
            await this.db.run(`DELETE FROM TAGDESCRIPTION
                WHERE tagName = $tag`, {
                $tag: tag
            });
        }
        catch (err) {
        }
    }
    async getDesc(tag) {
        const rows = [];
        const count = await new Promise((resolve, reject) => {
            this.db.each(`SELECT description FROM TAGDESCRIPTION
                WHERE tagName = $tag`, {
                $tag: tag
            }, (err, row) => {
                if (err)
                    reject(err);
                rows.push(row);
            }, (err, count) => {
                if (err)
                    reject(err);
                resolve(count);
            });
        });
        if (rows.length <= 0) {
            // throw new Error(`No tag information found for ${util.inspect(tag)}`);
            return undefined;
        }
        if (rows.length > 1) {
            throw new Error(`UNEXPECTED CONDITION more than one tag entry for ${util.inspect(tag)}`);
        }
        return (rows[0].description === null
            || typeof rows[0].description === 'undefined')
            ? undefined
            : rows[0].description;
    }
}
_TagDescriptions_db = new WeakMap();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFnLWdsdWUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9saWIvY2FjaGUvdGFnLWdsdWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQ0EsT0FBTyxJQUFJLE1BQU0sV0FBVyxDQUFDO0FBRzdCLDhDQUE4QztBQUU5QyxrREFBa0Q7QUFFbEQsTUFBTSxPQUFPLE9BQU87SUFBcEI7UUFDSSw4QkFBYztJQXlJbEIsQ0FBQztJQXZJRyxJQUFJLEVBQUUsS0FBZSxPQUFPLHVCQUFBLElBQUksbUJBQUksQ0FBQyxDQUFDLENBQUM7SUFFdkMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFZO1FBQ25CLHVCQUFBLElBQUksZUFBTyxFQUFFLE1BQUEsQ0FBQztRQUVkLE1BQU0sSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUM7Ozs7Ozs7Ozs7OztTQVlqQixDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQsS0FBSyxDQUFDLFVBQVUsQ0FBQyxLQUFhLEVBQUUsSUFBYztRQUMxQyxLQUFLLE1BQU0sR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDO1lBQ3JCLE1BQU0sSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUM7Ozs7Ozs7YUFPakIsRUFBRTtnQkFDQyxNQUFNLEVBQUUsS0FBSztnQkFDYixJQUFJLEVBQUUsR0FBRzthQUNaLENBQUMsQ0FBQztRQUNQLENBQUM7SUFDTCxDQUFDO0lBRUQsS0FBSyxDQUFDLGFBQWEsQ0FBQyxLQUFhO1FBQzdCLElBQUksQ0FBQztZQUNELE1BQU0sSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQ2IsNkNBQTZDLEVBQUU7Z0JBQzNDLE1BQU0sRUFBRSxLQUFLO2FBQ2hCLENBQ0osQ0FBQztRQUNOLENBQUM7UUFBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO1FBQ2YsQ0FBQztJQUNMLENBQUM7SUFFRCxLQUFLLENBQUMsSUFBSTtRQUNOLE1BQU0sSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUNoQixN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RUFBRSxNQUFNLEVBQUUsRUFBRTtZQUNoRCxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQztxQ0FDWSxFQUFFO2dCQUNuQixJQUFJLEVBQUUsR0FBRzthQUNaLEVBQ0QsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEVBQUU7Z0JBQ1QsSUFBSSxHQUFHO29CQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDckIsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNuQixDQUFDLEVBQ0QsQ0FBQyxHQUFHLEVBQUUsS0FBSyxFQUFFLEVBQUU7Z0JBQ1gsSUFBSSxHQUFHO29CQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDckIsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ25CLENBQUMsQ0FDSixDQUFDO1FBQ04sQ0FBQyxDQUFDLENBQUM7UUFDSCxJQUFJLElBQUksQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUFFLENBQUM7WUFDbkIsd0VBQXdFO1lBQ3hFLE9BQU8sU0FBUyxDQUFDO1FBQ3JCLENBQUM7UUFDRCxJQUFJLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUM7WUFDbEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxvREFBb0QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDN0YsQ0FBQztRQUNELE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxLQUFLLElBQUk7ZUFDN0IsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxLQUFLLFdBQVcsQ0FDaEQ7WUFDRyxDQUFDLENBQUMsU0FBUztZQUNYLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDO0lBQzlCLENBQUM7Q0FDSiIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHV0aWwgZnJvbSAnbm9kZTp1dGlsJztcbmltcG9ydCB7IERhdGFiYXNlIH0gZnJvbSAnc3FsaXRlMyc7XG5cbi8vIFVzZSB0aGlzLmRhby5zcWxkYiB0byBnZXQgRGF0YWJhc2UgaW5zdGFuY2VcblxuLy8gZnVuY3Rpb24gdG8gaW5pdGlhbGl6ZSBhIFRBR0dMVUUgZGF0YWJhc2UgdGFibGVcblxuZXhwb3J0IGNsYXNzIFRhZ0dsdWUge1xuICAgICNkYjogRGF0YWJhc2U7XG5cbiAgICBnZXQgZGIoKTogRGF0YWJhc2UgeyByZXR1cm4gdGhpcy4jZGI7IH1cblxuICAgIGFzeW5jIGluaXQoZGI6IERhdGFiYXNlKSB7XG4gICAgICAgIHRoaXMuI2RiID0gZGI7XG5cbiAgICAgICAgYXdhaXQgdGhpcy5kYi5ydW4oYFxuICAgICAgICBDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUU1xuICAgICAgICBUQUdHTFVFIChcbiAgICAgICAgICAgIGRvY3ZwYXRoIFNUUklORyxcbiAgICAgICAgICAgIHRhZ05hbWUgU1RSSU5HXG4gICAgICAgICk7XG4gICAgICAgIENSRUFURSBJTkRFWCBJRiBOT1QgRVhJU1RTIFxuICAgICAgICAgICAgdGFnZ2x1ZV92cGF0aCBvbiBUQUdHTFVFIChkb2N2cGF0aCk7XG4gICAgICAgIENSRUFURSBJTkRFWCBJRiBOT1QgRVhJU1RTXG4gICAgICAgICAgICB0YWdnbHVlX25hbWUgIG9uIFRBR0dMVUUgKHRhZ05hbWUpO1xuICAgICAgICBDUkVBVEUgVU5JUVVFIElOREVYIElGIE5PVCBFWElTVFNcbiAgICAgICAgICAgIHRhZ2dsdWVfdHVwbGUgT04gVEFHR0xVRSAoZG9jdnBhdGgsIHRhZ05hbWUpXG4gICAgICAgIGApO1xuICAgIH1cblxuICAgIGFzeW5jIGFkZFRhZ0dsdWUodnBhdGg6IHN0cmluZywgdGFnczogc3RyaW5nW10pIHtcbiAgICAgICAgZm9yIChjb25zdCB0YWcgb2YgdGFncykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5kYi5ydW4oYFxuICAgICAgICAgICAgSU5TRVJUIElOVE8gVEFHR0xVRSAoXG4gICAgICAgICAgICAgICAgZG9jdnBhdGgsIHRhZ05hbWVcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIFZBTFVFUyAoXG4gICAgICAgICAgICAgICAgJHZwYXRoLCAkdGFnXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBgLCB7XG4gICAgICAgICAgICAgICAgJHZwYXRoOiB2cGF0aCxcbiAgICAgICAgICAgICAgICAkdGFnOiB0YWdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZGVsZXRlVGFnR2x1ZSh2cGF0aDogc3RyaW5nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRiLnJ1bihcbiAgICAgICAgICAgICAgICBgREVMRVRFIEZST00gVEFHR0xVRSBXSEVSRSBkb2N2cGF0aCA9ICR2cGF0aGAsIHtcbiAgICAgICAgICAgICAgICAgICAgJHZwYXRoOiB2cGF0aCxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIHRhZ3MoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgICAgICBjb25zdCByb3dzID0gW107XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGIuZWFjaChgU0VMRUNUIERJU1RJTkNUIHRhZ05hbWUgQVMgdGFnIEZST00gVEFHR0xVRWAsXG4gICAgICAgICAgICAgICAgKGVyciwgcm93KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICByb3dzLnB1c2gocm93KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIChlcnIsIGNvdW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGNvdW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJvd3MubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS50YWc7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIHBhdGhzRm9yVGFnKHRhZ05hbWU6IHN0cmluZyB8IHN0cmluZ1tdKVxuICAgICAgICA6IFByb21pc2U8c3RyaW5nW10+XG4gICAge1xuICAgICAgICBjb25zdCByb3dzID0gW107XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGBwYXRoc0ZvclRhZyAke3V0aWwuaW5zcGVjdCh0YWdOYW1lKX1gKTtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YWdOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGIuZWFjaChgXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCBESVNUSU5DVCBkb2N2cGF0aCBBUyB2cGF0aFxuICAgICAgICAgICAgICAgICAgICBGUk9NIFRBR0dMVUVcbiAgICAgICAgICAgICAgICAgICAgV0hFUkUgdGFnTmFtZSA9ICR0YWdcbiAgICAgICAgICAgICAgICAgICAgYCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHRhZzogdGFnTmFtZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAoZXJyLCByb3cpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIChlcnIsIGNvdW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY291bnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0YWdOYW1lKSkge1xuXG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgYXJyYXkgaW50byB0aGUgU1FMXG4gICAgICAgICAgICAgICAgLy8gcmVwcmVzZW50YXRpb24gb2YgdGhlIGFycmF5XG4gICAgICAgICAgICAgICAgLy8gc3VpdGFibGUgZm9yIHRoZSBXSEVSRSBjbGF1c2UgYmVsb3cuXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbGV0IHRhZ3N0cmluZyA9IGAgKCAke3RhZ05hbWUubWFwKHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCcke3QuaW5kZXhPZihcIidcIikgPj0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0LnJlcGxhY2VBbGwoXCInXCIsIFwiJydcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdH0nYDtcbiAgICAgICAgICAgICAgICB9KS5qb2luKCcsJyl9ICkgYDtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRhZ3N0cmluZyk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRiLmVhY2goYFxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1QgRElTVElOQ1QgZG9jdnBhdGggQVMgdnBhdGhcbiAgICAgICAgICAgICAgICAgICAgRlJPTSBUQUdHTFVFXG4gICAgICAgICAgICAgICAgICAgIFdIRVJFIHRhZ05hbWUgSU4gJHt0YWdzdHJpbmd9XG4gICAgICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5zZXJ0aW5nIHRoZSB0YWdzdHJpbmcgaW4gdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vcm1hbCB3YXkgZGlkIG5vdCB3b3JrLCBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5zdGVhZCBnYXZlIGEgc3ludGF4IGVycm9yLlxuICAgICAgICAgICAgICAgICAgICAvLyBVc2luZyBKYXZhU2NyaXB0IHRlbXBsYXRlIHN0cmluZ3NcbiAgICAgICAgICAgICAgICAgICAgLy8gd29ya2VkLCBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyAsIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICR0YWdzOiB0YWdzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgICAgICAsXG4gICAgICAgICAgICAgICAgICAgIChlcnIsIHJvdykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3dzLnB1c2gocm93KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgKGVyciwgY291bnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcm93cy5tYXAoaXRlbSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS52cGF0aDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG59XG5cbmV4cG9ydCBjbGFzcyBUYWdEZXNjcmlwdGlvbnMge1xuXG4gICAgI2RiOiBEYXRhYmFzZTtcblxuICAgIGdldCBkYigpOiBEYXRhYmFzZSB7IHJldHVybiB0aGlzLiNkYjsgfVxuXG4gICAgYXN5bmMgaW5pdChkYjogRGF0YWJhc2UpIHtcbiAgICAgICAgdGhpcy4jZGIgPSBkYjtcblxuICAgICAgICBhd2FpdCB0aGlzLmRiLnJ1bihgXG4gICAgICAgIENSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTXG4gICAgICAgIFRBR0RFU0NSSVBUSU9OIChcbiAgICAgICAgICAgIHRhZ05hbWUgU1RSSU5HIFVOSVFVRSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uIFNUUklOR1xuICAgICAgICApO1xuICAgICAgICBDUkVBVEUgVU5JUVVFIElOREVYIElGIE5PVCBFWElTVFNcbiAgICAgICAgICAgIHRhZ2Rlc2NfbmFtZSAgb24gVEFHREVTQ1JJUFRJT04gKHRhZ05hbWUpO1xuICAgICAgICBgKTtcbiAgICB9XG5cbiAgICBhc3luYyBhZGREZXNjKHRhZzogc3RyaW5nLCBkZXNjcmlwdGlvbjogc3RyaW5nKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZGIucnVuKGBcbiAgICAgICAgSU5TRVJUIElOVE8gVEFHREVTQ1JJUFRJT04gKFxuICAgICAgICAgICAgdGFnTmFtZSwgZGVzY3JpcHRpb25cbiAgICAgICAgKVxuICAgICAgICBWQUxVRVMgKFxuICAgICAgICAgICAgJHRhZywgJGRlc2NcbiAgICAgICAgKVxuICAgICAgICBgLCB7XG4gICAgICAgICAgICAkdGFnOiB0YWcsXG4gICAgICAgICAgICAkZGVzYzogZGVzY3JpcHRpb25cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZGVsZXRlRGVzYyh0YWc6IHN0cmluZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5kYi5ydW4oXG4gICAgICAgICAgICAgICAgYERFTEVURSBGUk9NIFRBR0RFU0NSSVBUSU9OXG4gICAgICAgICAgICAgICAgV0hFUkUgdGFnTmFtZSA9ICR0YWdgLCB7XG4gICAgICAgICAgICAgICAgICAgICR0YWc6IHRhZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0RGVzYyh0YWc6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG5cbiAgICAgICAgY29uc3Qgcm93cyA9IFtdO1xuICAgICAgICBjb25zdCBjb3VudCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGIuZWFjaChgU0VMRUNUIGRlc2NyaXB0aW9uIEZST00gVEFHREVTQ1JJUFRJT05cbiAgICAgICAgICAgICAgICBXSEVSRSB0YWdOYW1lID0gJHRhZ2AsIHtcbiAgICAgICAgICAgICAgICAgICAgJHRhZzogdGFnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAoZXJyLCByb3cpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJvd3MucHVzaChyb3cpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKGVyciwgY291bnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY291bnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocm93cy5sZW5ndGggPD0gMCkge1xuICAgICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKGBObyB0YWcgaW5mb3JtYXRpb24gZm91bmQgZm9yICR7dXRpbC5pbnNwZWN0KHRhZyl9YCk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3dzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVU5FWFBFQ1RFRCBDT05ESVRJT04gbW9yZSB0aGFuIG9uZSB0YWcgZW50cnkgZm9yICR7dXRpbC5pbnNwZWN0KHRhZyl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChyb3dzWzBdLmRlc2NyaXB0aW9uID09PSBudWxsXG4gICAgICAgICAgICB8fCB0eXBlb2Ygcm93c1swXS5kZXNjcmlwdGlvbiA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgKVxuICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgIDogcm93c1swXS5kZXNjcmlwdGlvbjtcbiAgICB9XG59XG4iXX0=